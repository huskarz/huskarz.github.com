<!DOCTYPE html>
<html>
  <head>
    <title>BeeFramework入门-scaffold-II - Huskar Blog</title>
    
    <meta http-equiv="content-type" content="text/html;charset=utf-8">
    <link rel="stylesheet" href="/css/syntax.css" type="text/css" />
    <link rel="stylesheet" href="/css/main.css" type="text/css" />
    
    
  </head>
  <body>
    <div class="container">
          <div class="site">
               <div class="header">
                   <h1 class="title"><a href="/">Huskar Blog</a></h1>
               </div>
                <h1>BeeFramework入门-scaffold-II</h1>
                <div class="postdate">Posted on 13 Aug 2013</div>



<div class="post">
<h1 id='background'>Background</h1>

<p>书接上回<a href='http://huskarz.github.io/beeframework/tutorial/2013/08/10/BeeFramework%E5%85%A5%E9%97%A8-scaffold.html'>使用scaffold生成model&amp;controller</a>.</p>

<p>从server端返回一个file list 我们需要在一个scrollview里列出取得的书名。</p>

<h1 id='scaffold'>scaffold生成了些什么？</h1>

<h2 id='1file'>1.FILE</h2>

<pre><code>@interface FILE : BeeActiveObject
@property (nonatomic, retain) NSString *		content;
@property (nonatomic, retain) NSString *		filename;</code></pre>

<blockquote>
<p>数据会存在FILE里面。</p>
</blockquote>

<h2 id='2req_getfiles_action'>2.REQ_GETFILES_ACTION</h2>

<pre><code>@interface REQ_GETFILES_ACTION : BeeActiveObject
@property (nonatomic, retain) NSNumber *		fileCategory;</code></pre>

<blockquote>
<p>向server发的请求，这里只有一个参数&#8217;fileCategory&#8217;.</p>
</blockquote>

<h2 id='3resp_getfiles_action'>3.RESP_GETFILES_ACTION</h2>

<pre><code>@interface RESP_GETFILES_ACTION : BeeActiveObject
@property (nonatomic, retain) NSArray *		data;
@property (nonatomic, retain) NSString *		returncode;</code></pre>

<blockquote>
<p>server的response。data里面存储的数据最终会通过宏CONVERT_PROPERTY_CLASS( data, FILE )转换为一个list，其中的element是FILE。</p>
</blockquote>

<h2 id='4api_getfiles_action'>4.API_GETFILES_ACTION</h2>

<pre><code>@interface API_GETFILES_ACTION : BeeRoutine
@property (nonatomic, retain) REQ_GETFILES_ACTION *	req;
@property (nonatomic, retain) RESP_GETFILES_ACTION *	resp;</code></pre>

<blockquote>
<p>发送请求以及处理响应的BeeRoutine.</p>
</blockquote>

<h1 id='data_flow'>Data flow</h1>

<h2 id='1_send_request'>1. Send request</h2>

<blockquote>
<p>BeeRoutine已经封装了这些操作。既然API_GETFILES_ACTION继承自它，只需:</p>
</blockquote>

<pre><code>API_GETFILES_ACTION * api = [API_GETFILES_ACTION apiWithResponder:self];
api.req.fileCategory = @111;//set request parameters
[api send];</code></pre>

<blockquote>
<p>指定responder为self，需自定义</p>
</blockquote>

<pre><code>- (void)API_GETFILES_ACTION:(API_GETFILES_ACTION *)api</code></pre>

<blockquote>
<p>作为所有的action包括发送请求，请求结果的callback。 在API_GETFILES_ACTION::routine中,会调用</p>
</blockquote>

<pre><code>NSString * requestURI = @&quot;http://www.163.com/getFiles.action&quot;;
self.HTTP_GET( requestURI ).PARAM( [self.req objectToDictionary] );</code></pre>

<blockquote>
<p>完成request的发送。</p>
</blockquote>

<h2 id='2_process_response'>2. Process response</h2>

<blockquote>
<p>同样在API_GETFILES_ACTION::routine中</p>
</blockquote>

<pre><code>self.resp = [RESP_GETFILES_ACTION objectFromDictionary:(NSDictionary *)result];</code></pre>

<blockquote>
<p>在json文件中已经定义好了返回的格式，这里会直接转换为response。然后只需在自定义的responder里面提取出来</p>
</blockquote>

<pre><code>[self.files addObjectsFromArray:api.resp.data];</code></pre>

<blockquote>
<p>至此，从server取到数据并转换为内部model list.</p>
</blockquote>
</div>

<div id="related">
  <h2>Related Posts</h2>
  <ul class="posts">
    
      <li><span>10 Aug 2013</span> - <a href="/beeframework/tutorial/2013/08/10/BeeFramework%E5%85%A5%E9%97%A8-scaffold.html">BeeFramework入门-scaffold</a></li>
    
      <li><span>03 Aug 2013</span> - <a href="/jekyll/update/2013/08/03/Ruby%E7%8E%AF%E5%A2%83%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98.html">Ruby环境的若干问题!!</a></li>
    
      <li><span>02 Aug 2013</span> - <a href="/jekyll/update/2013/08/02/welcome-to-jekyll.html">Horray!!</a></li>
    
  </ul>
</div>


<div id="comments">
  <h2>Comments</h2>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_identifier = "/beeframework/tutorial/2013/08/13/BeeFramework%E5%85%A5%E9%97%A8-scaffold-II.html";
    (function() {
     var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
     dsq.src = 'http://huskar.disqus.com/embed.js';
     (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript=huskar">comments powered by Disqus.</a></noscript>
  <a href="http://disqus.com" class="dsq-brlink">blog comments powered by <span class="logo-disqus">Disqus</span></a>
</div>


          </div>
    </div> <!-- /container -->
  
  <a href="http://github.com/"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a>
  
  </body>
</html>
