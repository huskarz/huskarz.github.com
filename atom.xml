<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

 <title>Huskar Blog</title>
 <link href="http://blog.example.com/atom.xml" rel="self"/>
 <link href="http://blog.example.com/"/>
 <updated>2013-08-12T16:08:38+08:00</updated>
 <id>http://blog.example.com/</id>
 <author>
   <name>Huskar</name>
   <email>Huskar@outlook.com</email>
 </author>

 
 <entry>
   <title>BeeFramework入门-scaffold-II</title>
   <link href="http://blog.example.com/beeframework/tutorial/2013/08/10/BeeFramework%E5%85%A5%E9%97%A8-scaffold-II.html"/>
   <updated>2013-08-10T01:36:03+08:00</updated>
   <id>http://blog.example.com/beeframework/tutorial/2013/08/10/BeeFramework入门-scaffold-II</id>
   <content type="html">&lt;h1 id='background'&gt;Background&lt;/h1&gt;

&lt;p&gt;书接上回&lt;a href='http://huskarz.github.io/beeframework/tutorial/2013/08/10/BeeFramework%E5%85%A5%E9%97%A8-scaffold.html'&gt;使用scaffold生成model&amp;amp;controller&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;从server端返回一个file list 我们需要在一个scrollview里列出取得的书名。&lt;/p&gt;

&lt;h1 id='scaffold'&gt;scaffold生成了些什么？&lt;/h1&gt;

&lt;h2 id='1file'&gt;1.FILE&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@interface FILE : BeeActiveObject
@property (nonatomic, retain) NSString *		content;
@property (nonatomic, retain) NSString *		filename;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;数据会存在FILE里面。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='2req_getfiles_action'&gt;2.REQ_GETFILES_ACTION&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@interface REQ_GETFILES_ACTION : BeeActiveObject
@property (nonatomic, retain) NSNumber *		fileCategory;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;向server发的请求，这里只有一个参数&amp;#8217;fileCategory&amp;#8217;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='3resp_getfiles_action'&gt;3.RESP_GETFILES_ACTION&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@interface RESP_GETFILES_ACTION : BeeActiveObject
@property (nonatomic, retain) NSArray *		data;
@property (nonatomic, retain) NSString *		returncode;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;server的response。data里面存储的数据最终会通过宏CONVERT_PROPERTY_CLASS( data, FILE )转换为一个list，其中的element是FILE。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='4api_getfiles_action'&gt;4.API_GETFILES_ACTION&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;@interface API_GETFILES_ACTION : BeeRoutine
@property (nonatomic, retain) REQ_GETFILES_ACTION *	req;
@property (nonatomic, retain) RESP_GETFILES_ACTION *	resp;&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;发送请求以及处理响应的BeeRoutine.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id='data_flow'&gt;Data flow&lt;/h1&gt;

&lt;h2 id='1_send_request'&gt;1. Send request&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;BeeRoutine已经封装了这些操作。既然API_GETFILES_ACTION继承自它，只需:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;API_GETFILES_ACTION * api = [API_GETFILES_ACTION apiWithResponder:self];
api.req.fileCategory = @111;//set request parameters
[api send];&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;指定responder为self，需自定义&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;- (void)API_GETFILES_ACTION:(API_GETFILES_ACTION *)api&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;作为所有的action包括发送请求，请求结果的callback。 在API_GETFILES_ACTION::routine中,会调用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;NSString * requestURI = @&amp;quot;http://www.163.com/getFiles.action&amp;quot;;
self.HTTP_GET( requestURI ).PARAM( [self.req objectToDictionary] );&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;完成request的发送。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id='2_process_response'&gt;2. Process response&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;同样在API_GETFILES_ACTION::routine中&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;self.resp = [RESP_GETFILES_ACTION objectFromDictionary:(NSDictionary *)result];&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;在json文件中已经定义好了返回的格式，这里会直接转换为response。然后只需在自定义的responder里面提取出来&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;[self.files addObjectsFromArray:api.resp.data];&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;至此，从server取到数据并转换为内部model list.&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>BeeFramework入门-scaffold</title>
   <link href="http://blog.example.com/beeframework/tutorial/2013/08/10/BeeFramework%E5%85%A5%E9%97%A8-scaffold.html"/>
   <updated>2013-08-10T00:07:03+08:00</updated>
   <id>http://blog.example.com/beeframework/tutorial/2013/08/10/BeeFramework入门-scaffold</id>
   <content type="html">&lt;h1 id='background'&gt;Background&lt;/h1&gt;

&lt;p&gt;IOS APP需要从某个server取数据，该server返回的是json格式。假设返回的数据如下: &lt;pre&gt;
&lt;code&gt;
{
	data =
    (
        {
           filename = &quot;name1&quot;;
           content = &quot;content1&quot;;
        },
        {
		   filename = &quot;name2&quot;;
		   content = &quot;content2&quot;;
		 }
	);
	returncode = 400;
}
&lt;/code&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;h1 id='scaffold'&gt;Scaffold&lt;/h1&gt;

&lt;blockquote&gt;
&lt;p&gt;首先绝大部分的IOS APP都是通过与server交互获取动态数据,所以你需要写大量的代码(Model&amp;amp;Controller)用于处理server获取的数据。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Scaffold能自动生成配套的Model和Controller.让你从此解放而专注于view的设计。以后若server返回的数据有变，只需要修改配置文件，从新生成一遍就可以了。&lt;/p&gt;

&lt;h1 id='steps'&gt;Steps&lt;/h1&gt;

&lt;h2 id='1_edit_xxxxjson'&gt;1. edit xxxx.json&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;根据server返回的json格式,对应的xxxx.json如下(具体规则参考&lt;strong&gt;scaffold.md&lt;/strong&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;
&lt;code&gt;
{
    &quot;title&quot; : &quot;xxxxxx&quot;,
    &quot;author&quot;: &quot;whatever&quot;,

    &quot;server&quot; : 
    {
        &quot;development&quot; : &quot;/*取数据的server address*/&quot;
    },

    &quot;model&quot; :
    {
        &quot;FILE&quot; :
        {
		            &quot;filename&quot; : &quot;name1&quot;,
		            &quot;content&quot; : &quot;content1&quot;,
		    }
    },
    &quot;controller&quot; :
    {
        &quot;GET /getFiles.action&quot;:
        {
            &quot;request&quot; :
            {
                &quot;fileCategory&quot; : 111 
            },
            &quot;response&quot;: //server 返回json数据格式
            {
		            &quot;data&quot;:[&quot;{FILE}&quot;],//上面定义的model &quot;FILE&quot;
                &quot;returncode&quot;:&quot;400&quot;
            }
        }
     }
}
&lt;/code&gt;
&lt;/pre&gt;
&lt;h2 id='2_run_scaffold_xxxxjson'&gt;2. run &amp;#8220;scaffold xxxx.json&amp;#8221;&lt;/h2&gt;

&lt;blockquote&gt;
&lt;p&gt;运行后可以得到 xxxx.h 和 xxxx.mm，将他们加到工程中。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;至此,使用scaffold生成配套的controller和model,与server端获取数据并转换为model的代码已经完成。&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>Ruby环境的若干问题!!</title>
   <link href="http://blog.example.com/jekyll/update/2013/08/03/Ruby%E7%8E%AF%E5%A2%83%E8%8B%A5%E5%B9%B2%E9%97%AE%E9%A2%98.html"/>
   <updated>2013-08-03T00:38:03+08:00</updated>
   <id>http://blog.example.com/jekyll/update/2013/08/03/Ruby环境若干问题</id>
   <content type="html">&lt;p&gt;本来不需要ruby环境的。为了安装cocoapods，结果引出一堆安装问题。焦头烂额了两天，现在终于搞定了。&lt;/p&gt;

&lt;h2 id='download_specs48gz'&gt;不能download specs.4.8.gz&lt;/h2&gt;

&lt;p&gt;这个问题很坑爹，本来按照安装cocoapods的流程： &lt;pre&gt;
  &lt;code&gt;
    gem update --system
    sudo gem install cocoapods
  &lt;/code&gt;
&lt;/pre&gt; 结果发现被墙，于是修改源： &lt;a href='http://ruby.taobao.org'&gt;taobao镜像&lt;/a&gt; 但还是死活装不上，后来用 &lt;pre&gt;
&lt;code&gt;
    gem install cocoapods -V
&lt;/code&gt;
&lt;/pre&gt; 才发现没有permission. 但是你要用sudo就说不能download specs.4.8，我了个擦，玩儿人不是。 决定不管sudo，于是&lt;strong&gt;修改文件夹权限&lt;/strong&gt;，cocoapods顺利装上。&lt;/p&gt;

&lt;h2 id='jekyll'&gt;安装jekyll的问题&lt;/h2&gt;

&lt;p&gt;正常来说： &lt;pre&gt;
&lt;code&gt;
    $ gem install jekyll
&lt;/code&gt;
&lt;/pre&gt; 然后报错，得知ruby1.8.7版本太低，于是打算安装1.9.2 &lt;pre&gt;
&lt;code&gt;
    $ rvm install 1.9.2
&lt;/code&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;报错说macports有问题（当时心中千万匹草泥马） 按照此贴操作无果（应该有用，只是没有解决我的问题）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a href='http://www.cnblogs.com/8586/archive/2012/12/02/2797911.html'&gt;解决安装macports，不能更新的问题&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;我想这个只是解决单独安装macports的问题，因为使用sync绕过了resync带来的问题。 于是我像RVM是不是有神马设置可以绕开安装Macports时默认使用resync，果不其然让我找着了：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a href='https://rvm.io/integration/macports'&gt;使用autolibs&lt;/a&gt;
&lt;blockquote&gt;
&lt;p&gt;至此，一切都搞定。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
&lt;p&gt;期间还遇到了各种乱七八糟，形形色色的小问题，但记不太清了。先这样吧。&lt;/p&gt;
&lt;/blockquote&gt;</content>
 </entry>
 
 <entry>
   <title>Horray!!</title>
   <link href="http://blog.example.com/jekyll/update/2013/08/02/welcome-to-jekyll.html"/>
   <updated>2013-08-02T22:38:03+08:00</updated>
   <id>http://blog.example.com/jekyll/update/2013/08/02/welcome-to-jekyll</id>
   <content type="html">&lt;p&gt;Finally settle down!&lt;/p&gt;</content>
 </entry>
 

</feed>
